import aiohttp
import asyncio
import json
import hmac
import hashlib
import time
from typing import Dict, Set, Tuple, Optional, Callable
from collections import deque
from datetime import datetime
from configs_continuous import (
    BYBIT_API_URL, BYBIT_WS_URL, REQUEST_TIMEOUT, ENABLE_COIN_FILTER,
    BLACKLIST_COINS, WHITELIST_COINS, MIN_24H_VOLUME_USDT,
    MIN_LIQUIDITY_SCORE, USE_ONLY_TOP_LIQUID_COINS, WEBSOCKET_ENABLED,
    WEBSOCKET_RECONNECT_DELAY, WEBSOCKET_PING_INTERVAL,
    BYBIT_API_KEY, BYBIT_API_SECRET
)


class BybitClientAsync:
    """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –∫–ª–∏–µ–Ω—Ç –¥–ª—è Bybit —Å WebSocket –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –∏ API –¥–ª—è –∫–æ–º–∏—Å—Å–∏–π"""

    def __init__(self):
        self.base_url = BYBIT_API_URL
        self.ws_url = BYBIT_WS_URL
        self.api_key = BYBIT_API_KEY
        self.api_secret = BYBIT_API_SECRET
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (compatible; ArbitrageBot/8.0)',
            'Accept': 'application/json'
        }
        self.timeout = aiohttp.ClientTimeout(total=REQUEST_TIMEOUT)
        self.session = None
        self.ws_session = None
        self.ws_connection = None

        # –°—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö
        self.usdt_pairs: Dict[str, float] = {}
        self.coins: Set[str] = set()
        self.trading_pairs: Dict[Tuple[str, str], float] = {}
        self.pair_volumes: Dict[Tuple[str, str], float] = {}
        self.pair_liquidity: Dict[Tuple[str, str], float] = {}

        # –ö–æ–º–∏—Å—Å–∏–∏ –Ω–∞ –≤—ã–≤–æ–¥ (–∫—ç—à)
        self.withdrawal_fees: Dict[str, Dict] = {}  # {coin: {chain: fee}}
        self.min_withdrawal_fees: Dict[str, float] = {}  # {coin: min_fee}
        self.withdrawal_info_loaded = False

        # WebSocket –¥–∞–Ω–Ω—ã–µ
        self.ws_prices: Dict[str, float] = {}
        self.price_updates: deque = deque(maxlen=1000)
        self.last_update_time: Dict[str, datetime] = {}

        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        self.filtered_by_volume = 0
        self.filtered_by_liquidity = 0
        self.ws_updates_count = 0
        self.ws_running = False

        # Callback –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π
        self.on_price_update: Optional[Callable] = None

    async def __aenter__(self):
        await self.create_session()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.close()

    async def create_session(self):
        """–°–æ–∑–¥–∞—ë—Ç HTTP –∏ WebSocket —Å–µ—Å—Å–∏–∏"""
        if self.session is None:
            self.session = aiohttp.ClientSession(headers=self.headers, timeout=self.timeout)

        if WEBSOCKET_ENABLED and self.ws_session is None:
            self.ws_session = aiohttp.ClientSession()

    async def close(self):
        """–ó–∞–∫—Ä—ã–≤–∞–µ—Ç –≤—Å–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è"""
        self.ws_running = False

        if self.ws_connection:
            await self.ws_connection.close()
            self.ws_connection = None

        if self.ws_session:
            await self.ws_session.close()
            self.ws_session = None

        if self.session:
            await self.session.close()
            self.session = None

    def _generate_signature(self, params: Dict) -> str:
        """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç HMAC SHA256 –ø–æ–¥–ø–∏—Å—å –¥–ª—è Bybit API"""
        if not self.api_secret:
            return ""

        sign_payload = "&".join([f"{k}={v}" for k, v in sorted(params.items())])
        signature = hmac.new(
            self.api_secret.encode("utf-8"),
            sign_payload.encode("utf-8"),
            hashlib.sha256
        ).hexdigest()
        return signature

    async def load_withdrawal_fees(self):
        """
        –ó–∞–≥—Ä—É–∂–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ–º–∏—Å—Å–∏—è—Ö –Ω–∞ –≤—ã–≤–æ–¥ —á–µ—Ä–µ–∑ Bybit API
        –¢—Ä–µ–±—É–µ—Ç API –∫–ª—é—á–∏ (api_key –∏ api_secret)
        """
        if not self.api_key or not self.api_secret:
            print("[Bybit] ‚ö†Ô∏è  API –∫–ª—é—á–∏ –Ω–µ –∑–∞–¥–∞–Ω—ã, –∫–æ–º–∏—Å—Å–∏–∏ –Ω–∞ –≤—ã–≤–æ–¥ –Ω–µ –±—É–¥—É—Ç –∑–∞–≥—Ä—É–∂–µ–Ω—ã")
            print("[Bybit] ‚ÑπÔ∏è  –î–ª—è —Ç–æ—á–Ω–æ–≥–æ —Ä–∞—Å—á–µ—Ç–∞ –ø—Ä–∏–±—ã–ª–∏ –¥–æ–±–∞–≤—å—Ç–µ BYBIT_API_KEY –∏ BYBIT_API_SECRET –≤ .env")
            return False

        if self.session is None:
            await self.create_session()

        try:
            print("[Bybit] üì• –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–º–∏—Å—Å–∏–π –Ω–∞ –≤—ã–≤–æ–¥...")

            endpoint = "/v5/asset/coin/query-info"
            timestamp = str(int(time.time() * 1000))

            params = {
                "api_key": self.api_key,
                "timestamp": timestamp
            }

            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø–æ–¥–ø–∏—Å—å
            params["sign"] = self._generate_signature(params)

            url = f"{self.base_url}{endpoint}"

            async with self.session.get(url, params=params) as response:
                if response.status == 401:
                    print("[Bybit] ‚ùå –û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ API. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ BYBIT_API_KEY –∏ BYBIT_API_SECRET")
                    return False

                if response.status != 200:
                    print(f"[Bybit] ‚ö†Ô∏è  HTTP {response.status} –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∫–æ–º–∏—Å—Å–∏–π")
                    return False

                data = await response.json()

                if data.get('retCode') != 0:
                    print(f"[Bybit] ‚ö†Ô∏è  API –æ—à–∏–±–∫–∞: {data.get('retMsg', 'Unknown error')}")
                    return False

            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ
            self.withdrawal_fees.clear()
            self.min_withdrawal_fees.clear()

            rows = data.get('result', {}).get('rows', [])

            for coin_info in rows:
                coin = coin_info.get('coin', '').upper()
                if not coin:
                    continue

                chains = coin_info.get('chains', [])
                if not chains:
                    continue

                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–º–∏—Å—Å–∏–∏ –¥–ª—è –≤—Å–µ—Ö —Å–µ—Ç–µ–π
                self.withdrawal_fees[coin] = {}
                min_fee = float('inf')

                for chain_info in chains:
                    chain = chain_info.get('chain', '')
                    chain_type = chain_info.get('chainType', '')
                    withdraw_fee = chain_info.get('withdrawFee', '0')
                    withdraw_min = chain_info.get('withdrawMin', '0')

                    try:
                        fee = float(withdraw_fee)
                        min_amount = float(withdraw_min)

                        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å–µ—Ç–∏
                        self.withdrawal_fees[coin][chain_type or chain] = {
                            'fee': fee,
                            'min': min_amount,
                            'chain': chain
                        }

                        # –ò—â–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é –∫–æ–º–∏—Å—Å–∏—é
                        if fee > 0 and fee < min_fee:
                            min_fee = fee

                    except (ValueError, TypeError):
                        continue

                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é –∫–æ–º–∏—Å—Å–∏—é –¥–ª—è –º–æ–Ω–µ—Ç—ã
                if min_fee != float('inf'):
                    self.min_withdrawal_fees[coin] = min_fee

            self.withdrawal_info_loaded = True

            print(f"[Bybit] ‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ –∫–æ–º–∏—Å—Å–∏–π –¥–ª—è {len(self.withdrawal_fees)} –º–æ–Ω–µ—Ç")
            print(f"[Bybit] üí∞ –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã—Ö –∫–æ–º–∏—Å—Å–∏–π: {len(self.min_withdrawal_fees)}")

            # –ü—Ä–∏–º–µ—Ä—ã –∫–æ–º–∏—Å—Å–∏–π –¥–ª—è –ø–æ–ø—É–ª—è—Ä–Ω—ã—Ö –º–æ–Ω–µ—Ç
            sample_coins = ['BTC', 'ETH', 'USDT', 'BNB', 'SOL']
            print(f"[Bybit] üìä –ü—Ä–∏–º–µ—Ä—ã –º–∏–Ω–∏–º–∞–ª—å–Ω—ã—Ö –∫–æ–º–∏—Å—Å–∏–π –Ω–∞ –≤—ã–≤–æ–¥:")
            for coin in sample_coins:
                if coin in self.min_withdrawal_fees:
                    fee = self.min_withdrawal_fees[coin]
                    chains = list(self.withdrawal_fees[coin].keys())
                    print(f"        {coin}: {fee} (—Å–µ—Ç–∏: {', '.join(chains[:3])})")

            return True

        except Exception as e:
            print(f"[Bybit] ‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∫–æ–º–∏—Å—Å–∏–π: {e}")
            return False

    def get_min_withdrawal_fee(self, coin: str) -> Optional[float]:
        """
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é –∫–æ–º–∏—Å—Å–∏—é –Ω–∞ –≤—ã–≤–æ–¥ –¥–ª—è –º–æ–Ω–µ—Ç—ã

        Args:
            coin: –¢–∏–∫–µ—Ä –º–æ–Ω–µ—Ç—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä, 'BTC', 'USDT')

        Returns:
            –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –∫–æ–º–∏—Å—Å–∏—è –∏–ª–∏ None –µ—Å–ª–∏ –¥–∞–Ω–Ω—ã–µ –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã
        """
        coin = coin.upper()
        return self.min_withdrawal_fees.get(coin)

    def get_all_withdrawal_fees(self, coin: str) -> Optional[Dict]:
        """
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∏—Å—Å–∏–∏ –¥–ª—è –º–æ–Ω–µ—Ç—ã –ø–æ —Ä–∞–∑–Ω—ã–º —Å–µ—Ç—è–º

        Args:
            coin: –¢–∏–∫–µ—Ä –º–æ–Ω–µ—Ç—ã

        Returns:
            –°–ª–æ–≤–∞—Ä—å {chain: {'fee': float, 'min': float, 'chain': str}} –∏–ª–∏ None
        """
        coin = coin.upper()
        return self.withdrawal_fees.get(coin)

    def get_best_withdrawal_chain(self, coin: str) -> Optional[Dict]:
        """
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å–∞–º–æ–π –≤—ã–≥–æ–¥–Ω–æ–π —Å–µ—Ç–∏ –¥–ª—è –≤—ã–≤–æ–¥–∞

        Args:
            coin: –¢–∏–∫–µ—Ä –º–æ–Ω–µ—Ç—ã

        Returns:
            {'chain': str, 'fee': float, 'min': float} –∏–ª–∏ None
        """
        coin = coin.upper()
        if coin not in self.withdrawal_fees:
            return None

        chains = self.withdrawal_fees[coin]
        if not chains:
            return None

        # –ù–∞—Ö–æ–¥–∏–º —Å–µ—Ç—å —Å –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π –∫–æ–º–∏—Å—Å–∏–µ–π
        best_chain = min(
            chains.items(),
            key=lambda x: x[1]['fee']
        )

        return {
            'chain': best_chain[0],
            'fee': best_chain[1]['fee'],
            'min': best_chain[1]['min'],
            'chain_full': best_chain[1]['chain']
        }

    def _should_include_coin(self, coin: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –¥–æ–ª–∂–Ω–∞ –ª–∏ –º–æ–Ω–µ—Ç–∞ –±—ã—Ç—å –≤–∫–ª—é—á–µ–Ω–∞ –≤ –∞–Ω–∞–ª–∏–∑"""
        if not ENABLE_COIN_FILTER:
            return True
        if WHITELIST_COINS:
            return coin in WHITELIST_COINS
        return coin not in BLACKLIST_COINS

    def _calculate_liquidity_score(
            self,
            volume_24h: float,
            turnover_24h: float,
            bid_ask_spread_pct: float = None
    ) -> float:
        """–†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç –æ—Ü–µ–Ω–∫—É –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏ –ø–∞—Ä—ã (0-100)"""
        score = 0.0

        # –û—Ü–µ–Ω–∫–∞ –ø–æ –æ–±—ä—ë–º—É
        if volume_24h >= 5000000:
            score += 50
        elif volume_24h >= 1000000:
            score += 45
        elif volume_24h >= 500000:
            score += 40
        elif volume_24h >= 100000:
            score += 30
        elif volume_24h >= 50000:
            score += 20

        # –û—Ü–µ–Ω–∫–∞ –ø–æ –æ–±–æ—Ä–æ—Ç—É
        if turnover_24h >= 50000000:
            score += 30
        elif turnover_24h >= 10000000:
            score += 25
        elif turnover_24h >= 5000000:
            score += 20
        elif turnover_24h >= 1000000:
            score += 15
        elif turnover_24h >= 500000:
            score += 10

        # –û—Ü–µ–Ω–∫–∞ –ø–æ —Å–ø—Ä–µ–¥—É
        if bid_ask_spread_pct is not None:
            if bid_ask_spread_pct <= 0.02:
                score += 20
            elif bid_ask_spread_pct <= 0.05:
                score += 15
            elif bid_ask_spread_pct <= 0.1:
                score += 10
            elif bid_ask_spread_pct <= 0.2:
                score += 5
        else:
            score += 10

        return min(score, 100.0)

    async def load_usdt_pairs(self):
        """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –≤—Å–µ —Ç–æ—Ä–≥–æ–≤—ã–µ –ø–∞—Ä—ã —Å Bybit —Å —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–µ–π"""
        if self.session is None:
            await self.create_session()

        try:
            print("[Bybit] üì• –ó–∞–≥—Ä—É–∑–∫–∞ —Ç–æ—Ä–≥–æ–≤—ã—Ö –ø–∞—Ä...")

            url = f"{self.base_url}/v5/market/tickers"
            params = {'category': 'spot'}

            async with self.session.get(url, params=params) as response:
                response.raise_for_status()
                data = await response.json()

            # –û—á–∏—Å—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö
            self.usdt_pairs.clear()
            self.coins.clear()
            self.trading_pairs.clear()
            self.pair_volumes.clear()
            self.pair_liquidity.clear()

            filtered_count = 0
            self.filtered_by_volume = 0
            self.filtered_by_liquidity = 0

            result_list = data.get('result', {}).get('list', [])
            quote_currencies = ['USDT', 'USDC', 'BTC', 'ETH', 'BNB', 'BUSD', 'DAI', 'TRX', 'XRP', 'SOL', 'DOGE']

            all_pairs = []

            for ticker in result_list:
                symbol = ticker.get('symbol', '').replace('/', '').upper()

                try:
                    price = float(ticker.get('lastPrice', 0))
                    if price <= 0:
                        continue

                    volume_24h = float(ticker.get('volume24h', 0))
                    turnover_24h = float(ticker.get('turnover24h', 0))
                    bid = float(ticker.get('bid1Price', 0))
                    ask = float(ticker.get('ask1Price', 0))

                    bid_ask_spread_pct = None
                    if bid > 0 and ask > 0:
                        bid_ask_spread_pct = ((ask - bid) / bid) * 100

                except (ValueError, TypeError):
                    continue

                # –û–ø—Ä–µ–¥–µ–ª—è–µ–º base –∏ quote
                base = None
                quote = None
                for potential_quote in quote_currencies:
                    if symbol.endswith(potential_quote) and len(symbol) > len(potential_quote):
                        quote = potential_quote
                        base = symbol[:-len(potential_quote)]
                        break

                if not base or not quote:
                    continue

                # –ü—Ä–∏–º–µ–Ω—è–µ–º —Ñ–∏–ª—å—Ç—Ä –º–æ–Ω–µ—Ç
                if not self._should_include_coin(base) or not self._should_include_coin(quote):
                    filtered_count += 1
                    continue

                # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –æ–±—ä—ë–º –≤ USDT
                volume_usdt = turnover_24h if quote == 'USDT' else volume_24h * price

                # –û—Ü–µ–Ω–∫–∞ –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏
                liquidity_score = self._calculate_liquidity_score(
                    volume_24h, turnover_24h, bid_ask_spread_pct
                )

                all_pairs.append({
                    'base': base,
                    'quote': quote,
                    'price': price,
                    'volume_usdt': volume_usdt,
                    'liquidity_score': liquidity_score,
                    'symbol': symbol
                })

            # –§–∏–ª—å—Ç—Ä—É–µ–º –∏ —Å–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏
            filtered_pairs = []
            for pair in all_pairs:
                if pair['volume_usdt'] < MIN_24H_VOLUME_USDT:
                    self.filtered_by_volume += 1
                    continue

                if pair['liquidity_score'] < MIN_LIQUIDITY_SCORE:
                    self.filtered_by_liquidity += 1
                    continue

                filtered_pairs.append(pair)

            # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏
            filtered_pairs.sort(key=lambda x: x['liquidity_score'], reverse=True)

            # –ë–µ—Ä—ë–º —Ç–æ–ø –º–æ–Ω–µ—Ç –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω–æ
            if USE_ONLY_TOP_LIQUID_COINS > 0:
                filtered_pairs = filtered_pairs[:USE_ONLY_TOP_LIQUID_COINS * 3]

            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ
            for pair in filtered_pairs:
                base = pair['base']
                quote = pair['quote']
                price = pair['price']
                volume_usdt = pair['volume_usdt']
                liquidity_score = pair['liquidity_score']

                self.trading_pairs[(base, quote)] = price
                self.pair_volumes[(base, quote)] = volume_usdt
                self.pair_liquidity[(base, quote)] = liquidity_score
                self.coins.add(base)
                self.coins.add(quote)

                if quote == 'USDT':
                    self.usdt_pairs[base] = price

            print(f"[Bybit] ‚úì –ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(self.usdt_pairs)} USDT-–ø–∞—Ä")
            print(f"[Bybit] ‚úì –í—Å–µ–≥–æ —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –º–æ–Ω–µ—Ç: {len(self.coins)}")
            print(f"[Bybit] ‚úì –í—Å–µ–≥–æ —Ç–æ—Ä–≥–æ–≤—ã—Ö –ø–∞—Ä (–ª–∏–∫–≤–∏–¥–Ω—ã—Ö): {len(self.trading_pairs)}")

            if filtered_count > 0:
                print(f"[Bybit] üîç –û—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–æ –ø–æ white/blacklist: {filtered_count}")
            if self.filtered_by_volume > 0:
                print(f"[Bybit] üìâ –û—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–æ –ø–æ –æ–±—ä—ë–º—É (<${MIN_24H_VOLUME_USDT:,.0f}): {self.filtered_by_volume}")
            if self.filtered_by_liquidity > 0:
                print(
                    f"[Bybit] üíß –û—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–æ –ø–æ –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏ (score <{MIN_LIQUIDITY_SCORE}): {self.filtered_by_liquidity}")

            # –¢–æ–ø-10 —Å–∞–º—ã—Ö –ª–∏–∫–≤–∏–¥–Ω—ã—Ö –ø–∞—Ä
            top_liquid = sorted(self.pair_liquidity.items(), key=lambda x: x[1], reverse=True)[:10]
            print(f"\n[Bybit] üèÜ –¢–æ–ø-10 —Å–∞–º—ã—Ö –ª–∏–∫–≤–∏–¥–Ω—ã—Ö –ø–∞—Ä:")
            for (base, quote), score in top_liquid:
                volume = self.pair_volumes.get((base, quote), 0)
                price = self.trading_pairs.get((base, quote), 0)
                print(f"        {base}/{quote}: –æ—Ü–µ–Ω–∫–∞ {score:.1f}, –æ–±—ä—ë–º ${volume:,.0f}, —Ü–µ–Ω–∞ {price:.8f}")

            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º WebSocket –¥–∞–Ω–Ω—ã–µ
            self.ws_prices = self.usdt_pairs.copy()

            # –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–æ–º–∏—Å—Å–∏–∏ –Ω–∞ –≤—ã–≤–æ–¥
            await self.load_withdrawal_fees()

        except Exception as e:
            print(f"[Bybit] ‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –ø–∞—Ä: {e}")

    async def start_websocket(self, callback: Optional[Callable] = None):
        """–ó–∞–ø—É—Å–∫–∞–µ—Ç WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ü–µ–Ω –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏"""
        if not WEBSOCKET_ENABLED:
            print("[Bybit] WebSocket –æ—Ç–∫–ª—é—á–µ–Ω –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏")
            return

        if not self.usdt_pairs:
            print("[Bybit] ‚ö†Ô∏è  –°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∑–∏—Ç–µ –ø–∞—Ä—ã —á–µ—Ä–µ–∑ load_usdt_pairs()")
            return

        self.on_price_update = callback
        self.ws_running = True

        print(f"\n[Bybit] üîå –ó–∞–ø—É—Å–∫ WebSocket –¥–ª—è {len(self.usdt_pairs)} –ø–∞—Ä...")

        # –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ —Ç–∏–∫–µ—Ä—ã
        symbols = [f"{coin}USDT" for coin in self.usdt_pairs.keys()]

        # –†–∞–∑–±–∏–≤–∞–µ–º –Ω–∞ –±–∞—Ç—á–∏ (–º–∞–∫—Å–∏–º—É–º 50 –ø–∞—Ä –≤ –æ–¥–Ω–æ–π –ø–æ–¥–ø–∏—Å–∫–µ)
        batch_size = 50
        tasks = []

        for i in range(0, len(symbols), batch_size):
            batch = symbols[i:i + batch_size]
            tasks.append(self._websocket_worker(batch))

        print(f"[Bybit] üì° –°–æ–∑–¥–∞–Ω–æ {len(tasks)} WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π")

        # –ó–∞–ø—É—Å–∫–∞–µ–º –≤—Å–µ –≤–æ—Ä–∫–µ—Ä—ã
        await asyncio.gather(*tasks, return_exceptions=True)

    async def _websocket_worker(self, symbols: list):
        """–í–æ—Ä–∫–µ—Ä –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ WebSocket –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ –≥—Ä—É–ø–ø—É —Å–∏–º–≤–æ–ª–æ–≤"""
        while self.ws_running:
            try:
                async with self.ws_session.ws_connect(self.ws_url) as ws:
                    # –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ —Ç–∏–∫–µ—Ä—ã
                    subscribe_msg = {
                        "op": "subscribe",
                        "args": [f"tickers.{symbol}" for symbol in symbols]
                    }
                    await ws.send_json(subscribe_msg)

                    print(f"[Bybit WS] ‚úì –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ {len(symbols)} —Å–∏–º–≤–æ–ª–æ–≤")

                    # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è
                    async for msg in ws:
                        if msg.type == aiohttp.WSMsgType.TEXT:
                            await self._handle_ws_message(msg.data)
                        elif msg.type == aiohttp.WSMsgType.CLOSED:
                            print(f"[Bybit WS] ‚ö†Ô∏è  –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ")
                            break
                        elif msg.type == aiohttp.WSMsgType.ERROR:
                            print(f"[Bybit WS] ‚ùå –û—à–∏–±–∫–∞: {ws.exception()}")
                            break

            except Exception as e:
                if self.ws_running:
                    print(f"[Bybit WS] ‚ùå –û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è: {e}")
                    print(f"[Bybit WS] üîÑ –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —á–µ—Ä–µ–∑ {WEBSOCKET_RECONNECT_DELAY}—Å...")
                    await asyncio.sleep(WEBSOCKET_RECONNECT_DELAY)
                else:
                    break

    async def _handle_ws_message(self, data: str):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç WebSocket"""
        try:
            msg = json.loads(data)

            # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–ª—É–∂–µ–±–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
            if 'op' in msg:
                return

            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–∏–∫–µ—Ä–∞
            if 'topic' in msg and msg['topic'].startswith('tickers.'):
                ticker_data = msg.get('data', {})
                symbol = ticker_data.get('symbol', '').upper()

                # –ò–∑–≤–ª–µ–∫–∞–µ–º base –º–æ–Ω–µ—Ç—É
                if symbol.endswith('USDT'):
                    coin = symbol[:-4]
                    price = float(ticker_data.get('lastPrice', 0))

                    if price > 0 and coin in self.usdt_pairs:
                        old_price = self.ws_prices.get(coin, 0)
                        self.ws_prices[coin] = price
                        self.usdt_pairs[coin] = price
                        self.last_update_time[coin] = datetime.now()
                        self.ws_updates_count += 1

                        # –õ–æ–≥–∏—Ä—É–µ–º –∫–∞–∂–¥—ã–µ 100 –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π
                        if self.ws_updates_count % 100 == 0:
                            print(f"[Bybit WS] üìä –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π: {self.ws_updates_count}")

                        # –í—ã–∑—ã–≤–∞–µ–º callback –µ—Å–ª–∏ –∑–∞–¥–∞–Ω
                        if self.on_price_update and abs(price - old_price) / old_price > 0.001:
                            await self.on_price_update(coin, old_price, price)

        except Exception as e:
            print(f"[Bybit WS] ‚ö†Ô∏è  –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")

    def get_price(self, base: str, quote: str) -> Optional[float]:
        """–ü–æ–ª—É—á–∞–µ—Ç —Ü–µ–Ω—É –¥–ª—è –ø–∞—Ä—ã BASE/QUOTE"""
        direct = self.trading_pairs.get((base, quote))
        if direct is not None:
            return direct
        reverse = self.trading_pairs.get((quote, base))
        if reverse is not None and reverse > 0:
            return 1.0 / reverse
        return None

    def get_liquidity_score(self, base: str, quote: str) -> float:
        """–ü–æ–ª—É—á–∞–µ—Ç –æ—Ü–µ–Ω–∫—É –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏ –ø–∞—Ä—ã"""
        score = self.pair_liquidity.get((base, quote))
        if score is not None:
            return score
        score = self.pair_liquidity.get((quote, base))
        return score if score is not None else 0.0

    def get_volume_24h(self, base: str, quote: str) -> float:
        """–ü–æ–ª—É—á–∞–µ—Ç –æ–±—ä—ë–º —Ç–æ—Ä–≥–æ–≤ –∑–∞ 24—á –≤ USDT"""
        volume = self.pair_volumes.get((base, quote))
        if volume is not None:
            return volume
        volume = self.pair_volumes.get((quote, base))
        return volume if volume is not None else 0.0

    def has_trading_pair(self, base: str, quote: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –Ω–∞–ª–∏—á–∏–µ —Ç–æ—Ä–≥–æ–≤–æ–π –ø–∞—Ä—ã"""
        return self.get_price(base, quote) is not None

    def is_liquid_pair(self, base: str, quote: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–∞—Ä–∞ –ª–∏–∫–≤–∏–¥–Ω–æ–π"""
        return self.get_liquidity_score(base, quote) >= MIN_LIQUIDITY_SCORE

    async def get_usdt_tickers(self) -> Dict[str, float]:
        """–ü–æ–ª—É—á–∞–µ—Ç –≤—Å–µ USDT-–ø–∞—Ä—ã"""
        if not self.usdt_pairs:
            await self.load_usdt_pairs()
        return self.usdt_pairs

    def get_available_quotes_for(self, base: str) -> Set[str]:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—Å–µ –≤–∞–ª—é—Ç—ã, —Å –∫–æ—Ç–æ—Ä—ã–º–∏ –º–æ–∂–µ—Ç —Ç–æ—Ä–≥–æ–≤–∞—Ç—å—Å—è base"""
        quotes = set()
        for (b, q) in self.trading_pairs.keys():
            if b == base:
                quotes.add(q)
            elif q == base:
                quotes.add(b)
        return quotes

    def get_liquid_usdt_coins(self) -> list:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –º–æ–Ω–µ—Ç —Å USDT-–ø–∞—Ä–∞–º–∏, –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏"""
        coins_with_scores = []
        for coin in self.usdt_pairs.keys():
            score = self.get_liquidity_score(coin, 'USDT')
            volume = self.get_volume_24h(coin, 'USDT')
            coins_with_scores.append((coin, score, volume))
        coins_with_scores.sort(key=lambda x: x[1], reverse=True)
        return [coin for coin, score, volume in coins_with_scores]

    def get_ws_statistics(self) -> Dict:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É WebSocket"""
        return {
            'running': self.ws_running,
            'updates_count': self.ws_updates_count,
            'tracked_pairs': len(self.ws_prices),
            'last_updates': len([t for t in self.last_update_time.values()
                                 if (datetime.now() - t).seconds < 60])
        }